# üóÑÔ∏è Base de Donn√©es avec Prisma - Guide Complet

## üéØ Vue d'ensemble

Prisma est au c≈ìur de notre architecture de donn√©es, fournissant une couche ORM type-safe, moderne et performante pour MySQL. Cette section documente l'utilisation compl√®te de Prisma dans notre application.

**Avantages cl√©s :**
- **Type Safety** : Pr√©vention des erreurs SQL √† la compilation
- **Migrations automatiques** : Versioning des changements de sch√©ma
- **Query Builder intuitif** : API JavaScript naturelle
- **Performance optimis√©e** : Requ√™tes SQL g√©n√©r√©es et optimis√©es
- **Introspection** : Synchronisation bidirectionnelle avec la base

## ÔøΩ Structure Compl√®te

```
prisma/
‚îú‚îÄ‚îÄ schema.prisma        # üìã Sch√©ma principal de la base de donn√©es
‚îú‚îÄ‚îÄ migrations/          # üì¶ Historique des migrations versionn√©es
‚îÇ   ‚îú‚îÄ‚îÄ 20241021000000_init/         # Migration initiale
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ migration.sql            # Script SQL de la migration
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ snapshot.json           # √âtat du sch√©ma apr√®s migration
‚îÇ   ‚îî‚îÄ‚îÄ migration_lock.toml         # Verrou pour √©viter conflits
‚îú‚îÄ‚îÄ seed.js             # üå± Script de peuplement (donn√©es test/dev)
‚îî‚îÄ‚îÄ README.md           # üìö Cette documentation
```

**Workflow type :**
1. **Modification** du `schema.prisma`
2. **G√©n√©ration** de migration avec `prisma migrate dev`
3. **Application** automatique en base locale
4. **G√©n√©ration** du client TypeScript mis √† jour
5. **Commit** des fichiers de migration pour l'√©quipe

## üèóÔ∏è Sch√©ma de Base de Donn√©es

**Fichier :** `schema.prisma`
```prisma
// Configuration du g√©n√©rateur de client
generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

// Configuration de la source de donn√©es
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// Mod√®le utilisateur avec contraintes et optimisations
model User {
  id           Int      @id @default(autoincrement())
  username     String   @unique @db.VarChar(30)
  passwordHash String   @db.VarChar(255)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Index pour optimiser les requ√™tes de recherche
  @@index([username])
  @@index([createdAt])
  
  // Mapping vers la table MySQL existante
  @@map("users")
}

// Exemple d'extension future : Sessions persistantes
// model Session {
//   id        String   @id @default(cuid())
//   userId    Int
//   user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
//   expiresAt DateTime
//   createdAt DateTime @default(now())
//   
//   @@index([userId])
//   @@index([expiresAt])
//   @@map("sessions")
// }
```

**D√©tails du mod√®le User :**
- **id** : Cl√© primaire auto-incr√©ment√©e (performance optimale)
- **username** : Contrainte unique avec index (recherche rapide)
- **passwordHash** : Stockage s√©curis√© (jamais le mot de passe en clair)
- **timestamps** : Audit automatique des cr√©ations/modifications
- **indexes** : Optimisation des requ√™tes fr√©quentes

## üöÄ Commandes Essentielles

### D√©veloppement
```bash
# G√©n√©rer le client Prisma
npx prisma generate

# Appliquer les migrations en dev
npx prisma migrate dev --name nom_migration

# R√©initialiser la base (‚ö†Ô∏è supprime les donn√©es)
npx prisma migrate reset

# Interface graphique pour explorer les donn√©es
npx prisma studio
```

### Production
```bash
# Appliquer les migrations en production
npx prisma migrate deploy

# G√©n√©rer le client (apr√®s d√©ploiement)
npx prisma generate
```

### Utilitaires
```bash
# Synchroniser le sch√©ma avec une DB existante
npx prisma db pull

# Valider le sch√©ma
npx prisma validate

# Formatter le sch√©ma
npx prisma format
```

## ‚öôÔ∏è Configuration Avanc√©e

### Variables d'Environnement D√©taill√©es
```bash
# D√©veloppement (.env) - Configuration locale
DATABASE_URL="mysql://username:password@localhost:3306/secure_api?schema=public&connection_limit=10&pool_timeout=20&socket_timeout=60"

# Test (.env.test) - Base de donn√©es isol√©e pour les tests
DATABASE_URL="mysql://username:password@localhost:3306/secure_api_test?schema=public&connection_limit=5"

# Production - Configuration optimis√©e avec SSL
DATABASE_URL="mysql://username:password@prod-host:3306/secure_api?sslmode=require&connection_limit=20&pool_timeout=20&socket_timeout=60&sslcert=./certs/client-cert.pem&sslkey=./certs/client-key.pem&sslrootcert=./certs/ca-cert.pem"
```

**Param√®tres d'URL expliqu√©s :**
- `connection_limit` : Nombre max de connexions simultan√©es
- `pool_timeout` : Timeout d'acquisition de connexion (secondes)
- `socket_timeout` : Timeout des requ√™tes MySQL (secondes)
- `sslmode` : Mode SSL (disable, prefer, require)

### Client Prisma Optimis√© (`src/config/database.js`)
```javascript
import { PrismaClient } from '@prisma/client';

// Configuration diff√©renci√©e par environnement
const getLogLevel = () => {
  switch (process.env.NODE_ENV) {
    case 'development':
      return ['query', 'info', 'warn', 'error'];
    case 'test':
      return ['error']; // Silencieux en test
    case 'production':
      return ['error']; // Seulement les erreurs en prod
    default:
      return ['info', 'warn', 'error'];
  }
};

export const prisma = new PrismaClient({
  log: getLogLevel(),
  errorFormat: 'pretty',
  
  // Configuration avanc√©e du datasource
  datasources: {
    db: {
      url: process.env.DATABASE_URL
    }
  },
  
  // M√©triques de performance (optionnel)
  __internal: {
    measurePerformance: process.env.NODE_ENV === 'development'
  }
});

// Middleware pour logging des requ√™tes lentes
prisma.$use(async (params, next) => {
  const before = Date.now();
  const result = await next(params);
  const after = Date.now();
  
  const queryTime = after - before;
  if (queryTime > 1000) { // Log si > 1 seconde
    console.warn(`üêå Requ√™te lente d√©tect√©e: ${params.model}.${params.action} (${queryTime}ms)`);
  }
  
  return result;
});

// Gestion gracieuse de la fermeture avec retry
const gracefulShutdown = async () => {
  console.log('üîå Fermeture des connexions Prisma...');
  let retries = 3;
  
  while (retries > 0) {
    try {
      await prisma.$disconnect();
      console.log('‚úÖ Connexions Prisma ferm√©es');
      break;
    } catch (error) {
      retries--;
      console.error(`‚ùå Erreur fermeture Prisma (${retries} tentatives restantes):`, error.message);
      if (retries === 0) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
};

// Gestionnaires de signaux pour shutdown gracieux
process.on('SIGINT', gracefulShutdown);
process.on('SIGTERM', gracefulShutdown);
process.on('beforeExit', gracefulShutdown);

// Test de connexion au d√©marrage
export const testDatabaseConnection = async () => {
  try {
    await prisma.$connect();
    console.log('‚úÖ Connexion base de donn√©es √©tablie');
    
    // Test de requ√™te simple
    await prisma.$queryRaw`SELECT 1 as test`;
    console.log('‚úÖ Base de donn√©es op√©rationnelle');
    
  } catch (error) {
    console.error('‚ùå Erreur connexion base de donn√©es:', error.message);
    console.error('üí° V√©rifiez votre DATABASE_URL et que MySQL fonctionne');
    process.exit(1);
  }
};
```

## üîÑ Workflow des Migrations

### 1. Modifier le Sch√©ma
```prisma
// Exemple : Ajouter un champ email
model User {
  id           Int      @id @default(autoincrement())
  username     String   @unique @db.VarChar(30)
  email        String   @unique @db.VarChar(100) // ‚Üê Nouveau champ
  passwordHash String   @db.VarChar(255)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("users")
}
```

### 2. Cr√©er la Migration
```bash
npx prisma migrate dev --name add_email_field
```

### 3. Appliquer Automatiquement
- Migration appliqu√©e sur la DB locale
- Fichier SQL g√©n√©r√© dans `prisma/migrations/`
- Client Prisma mis √† jour automatiquement

## üõ°Ô∏è S√©curit√© et Performance - Bonnes Pratiques

### Protection SQL Injection Garantie
```javascript
// ‚úÖ S√âCURIS√â - Prisma param√©trise automatiquement
const user = await prisma.user.findUnique({
  where: { username: userInput } // Impossible d'injecter du SQL
});

const users = await prisma.user.findMany({
  where: {
    username: { contains: searchTerm }, // Recherche s√©curis√©e
    createdAt: { gte: new Date(dateFilter) } // Dates s√©curis√©es
  }
});

// ‚ö†Ô∏è SQL brut - √Ä utiliser avec pr√©caution
const result = await prisma.$queryRaw`
  SELECT COUNT(*) as total 
  FROM users 
  WHERE created_at > ${startDate}
`; // Prisma param√©trise m√™me le SQL brut

// ‚ùå JAMAIS FAIRE - Concat√©nation directe
// const query = `SELECT * FROM users WHERE username = '${userInput}'`; // VULN√âRABLE
```

### Optimisations de Performance

#### 1. S√©lection de Champs Cibl√©e
```javascript
// ‚úÖ Select sp√©cifique - √âconomise bande passante et m√©moire
const publicUser = await prisma.user.findUnique({
  where: { id: userId },
  select: {
    id: true,
    username: true,
    createdAt: true
    // passwordHash intentionnellement omis pour la s√©curit√©
  }
});

// ‚úÖ Exclusion de champs sensibles avec omit (Prisma 5+)
const userWithoutPassword = await prisma.user.findUnique({
  where: { id: userId },
  omit: { passwordHash: true }
});
```

#### 2. Pagination et Tri Optimis√©s
```javascript
// ‚úÖ Pagination cursor-based (plus performante pour grandes tables)
const users = await prisma.user.findMany({
  take: 20,
  cursor: lastUserId ? { id: lastUserId } : undefined,
  skip: lastUserId ? 1 : 0,
  orderBy: { id: 'desc' }
});

// ‚úÖ Pagination offset-based (plus simple, moins performante)
const page = 2, limit = 10;
const users = await prisma.user.findMany({
  skip: (page - 1) * limit,
  take: limit,
  orderBy: { createdAt: 'desc' }
});

// ‚úÖ Compter avec pagination optimis√©e
const [users, totalCount] = await Promise.all([
  prisma.user.findMany({
    skip: (page - 1) * limit,
    take: limit,
    orderBy: { createdAt: 'desc' }
  }),
  prisma.user.count({
    where: searchConditions
  })
]);
```

#### 3. Requ√™tes Complexes Optimis√©es
```javascript
// ‚úÖ Requ√™te avec conditions multiples et index
const activeUsers = await prisma.user.findMany({
  where: {
    AND: [
      { createdAt: { gte: thirtyDaysAgo } }, // Utilise l'index sur createdAt
      { username: { not: null } } // Filtre les utilisateurs valides
    ]
  },
  orderBy: [
    { createdAt: 'desc' }, // Index principal
    { username: 'asc' }    // Index secondaire
  ]
});

// ‚úÖ Agr√©gations performantes
const userStats = await prisma.user.aggregate({
  _count: true,
  _min: { createdAt: true },
  _max: { createdAt: true },
  where: {
    createdAt: { gte: startOfMonth }
  }
});
```

### Connection Pooling Avanc√©
```javascript
// Configuration optimis√©e du pool dans DATABASE_URL
const getDatabaseUrl = () => {
  const baseUrl = process.env.DATABASE_URL;
  
  // Param√®tres selon l'environnement
  const poolConfig = {
    development: 'connection_limit=5&pool_timeout=20',
    test: 'connection_limit=2&pool_timeout=10',
    production: 'connection_limit=20&pool_timeout=30&socket_timeout=60'
  };
  
  const config = poolConfig[process.env.NODE_ENV] || poolConfig.development;
  return `${baseUrl}?${config}`;
};

// Monitoring des connexions (d√©veloppement)
if (process.env.NODE_ENV === 'development') {
  setInterval(async () => {
    try {
      const metrics = await prisma.$metrics.json();
      console.log('üìä Pool de connexions:', {
        active: metrics.counters.find(c => c.key === 'prisma_pool_connections_open')?.value || 0,
        idle: metrics.counters.find(c => c.key === 'prisma_pool_connections_idle')?.value || 0
      });
    } catch (error) {
      // M√©triques non disponibles dans toutes les versions
    }
  }, 30000); // Toutes les 30 secondes
}
```

### Gestion des Transactions
```javascript
// ‚úÖ Transaction simple
const transferUser = await prisma.$transaction(async (tx) => {
  const user = await tx.user.update({
    where: { id: userId },
    data: { username: newUsername }
  });
  
  // Log de l'action
  await tx.auditLog.create({
    data: {
      userId: user.id,
      action: 'username_change',
      oldValue: oldUsername,
      newValue: newUsername
    }
  });
  
  return user;
});

// ‚úÖ Transaction avec retry automatique
const createUserWithRetry = async (userData, maxRetries = 3) => {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await prisma.$transaction(async (tx) => {
        return await tx.user.create({
          data: userData,
          select: { id: true, username: true, createdAt: true }
        });
      });
    } catch (error) {
      if (attempt === maxRetries || !isRetryableError(error)) {
        throw error;
      }
      
      const delay = Math.pow(2, attempt) * 1000; // Backoff exponentiel
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
};

const isRetryableError = (error) => {
  return error.code === 'P2034' || // Transaction conflict
         error.code === 'P1001' || // Connection error
         error.message.includes('timeout');
};
```

## üîß Maintenance

### Scripts Utiles (`package.json`)
```json
{
  "scripts": {
    "db:reset": "npx prisma migrate reset --force",
    "db:studio": "npx prisma studio",
    "db:generate": "npx prisma generate",
    "db:migrate": "npx prisma migrate dev",
    "db:deploy": "npx prisma migrate deploy"
  }
}
```

### Backup et Restore
```bash
# Backup
mysqldump -u user -p secure_api > backup.sql

# Restore
mysql -u user -p secure_api < backup.sql
```

## üß™ Tests avec Prisma

### Configuration Test
```javascript
// tests/setup.js
import { prisma } from '../src/config/database.js';

beforeEach(async () => {
  // Nettoyer les donn√©es de test
  await prisma.user.deleteMany();
});

afterAll(async () => {
  await prisma.$disconnect();
});
```

### Base de Donn√©es de Test
```bash
# Utiliser setup-test-db.sh pour cr√©er la base de test
./setup-test-db.sh

# Ou manuellement
export DATABASE_URL="mysql://user:pass@localhost:3306/secure_api_test"
npx prisma migrate dev --name test-init
```

## üìä Monitoring

### Logs des Requ√™tes
```javascript
// En d√©veloppement
const prisma = new PrismaClient({
  log: [
    { level: 'query', emit: 'event' },
    { level: 'error', emit: 'stdout' },
    { level: 'info', emit: 'stdout' },
    { level: 'warn', emit: 'stdout' },
  ],
});

prisma.$on('query', (e) => {
  console.log('Query: ' + e.query);
  console.log('Duration: ' + e.duration + 'ms');
});
```

### M√©triques Performance
- **Connection pool** : Surveiller les connexions actives
- **Slow queries** : Logs des requ√™tes > 100ms
- **Error rate** : Taux d'erreurs de connexion

## üö® D√©pannage

### Erreurs Courantes

**"Can't reach database server"**
```bash
# V√©rifier MySQL
sudo systemctl status mysql
sudo systemctl start mysql

# Tester la connexion
mysql -u user -p -h localhost
```

**"Access denied"**
```bash
# V√©rifier les droits utilisateur
mysql -u root -p -e "SHOW GRANTS FOR 'user'@'localhost';"

# Donner les droits n√©cessaires
GRANT ALL PRIVILEGES ON secure_api.* TO 'user'@'localhost';
```

**"Migration failed"**
```bash
# Voir l'historique des migrations
npx prisma migrate status

# Forcer la r√©solution
npx prisma migrate resolve --applied "migration_name"
```

### Reset Complet
```bash
# ‚ö†Ô∏è SUPPRIME TOUTES LES DONN√âES
npx prisma migrate reset --force
npx prisma generate
```

## üéØ Bonnes Pratiques

1. **Toujours** utiliser `select` pour √©viter les fuites de donn√©es sensibles
2. **Jamais** commit les `.env` avec vrais passwords
3. **Toujours** tester les migrations sur une copie avant prod
4. **Utiliser** des transactions pour les op√©rations critiques
5. **Monitor** les performances des requ√™tes

## üìà √âvolutions Pr√©vues

- **Audit trail** : Log des modifications
- **Soft delete** : Suppression logique
- **Roles/Permissions** : Syst√®me de droits
- **Indexes** : Optimisation des requ√™tes fr√©quentes